---
title: "Generalized Procrustes Analysis"
subtitle: Morfometria Geométrica - Aula 2
author: "Guilherme Garcia"
logo: ../Figuras/logo.jpg
date: "18 de Novembro de 2014"
output:
  ioslides_presentation: 
    mathjax: default
    toc: yes
bibliography: ../cursoGM.bib
---

# Preliminares

```{r load_pack, include = FALSE}
require(shapes)
require(geomorph)
```

## O que é a GPA? 

A GPA ('Generalized Procrustes Analysis') consiste em realizar uma série de
operações sobre um conjunto de configurações de marcos, de maneira a remover deste
conjunto aquela variação que não é informativa do ponto de vista biológico:

> - Translação

> - Rotação

> - Escala

## Mas... {.build}

Variação em escala é importante do ponto de vista biológico.

A GPA nos permite separar a variação associada à escala daquela
associada à forma, de modo que é possível estimar efeitos alométricos
sobre a variação de forma.

**Alometria**: associação entre um caráter de interesse (morfológico, fisiológico,
ou até mesmo ecológico) e tamanho corporal [@huxley_problems_1932].

<div class='notes'>

escala log-log

</div>

# Passo a Passo 

* $k$: número de marcos anatômicos
* $m$: dimensões
* $n$: número de indivíduos

## Centróide {.flexbox .vcenter .hcenter}

![Posição do Centróide](centroid.jpg)

$$C_j = \frac{1}{k}\sum_{i=1}^{k}X_{ij}$$

<div class='notes'>
Média aritmética simples entre os valores em cada marco,
para cada uma das $m$ dimensões.
</div>

----

```{r}
X <- matrix(c(-1, -1, 1, -1, 0, 1), nrow = 3, byrow = T)
X
colMeans(X)
```

## Tamanho do Centróide {.flexbox .vcenter .hcenter}

![Tamanho do Centróide](centroidsize.jpg)

$$CS(X) = \sqrt{\sum_{i=1}^{k}\sum_{j=1}^{m}(X_{ij} - C_j)^2}$$

<div class='notes'>
CS (X) = $\sqrt{L1^2 + L2^2 + L3^2}$
</div>

----

```{r}
centroid.size(X)
```

Assim, o tamanho do centróide é a variável
que representa a variação de escala.

@bookstein_morphometric_1991 demonstrou que o $CS$ é uma variável
"pura" de tamanho.

<div class='notes'>

Isso significa que, dada uma população de configurações desprovida de
relações alométricas, o CS necessariamente irá possuir correlações
nulas com as variáveis de forma. Outras medidas que podem ser
entendidas como tamanho, como por exemplo o comprimento total do
crânio, podem ter correlações com as variáveis de forma, de modo que
esse tipo de medida é na verdade uma combinação entre escala e forma. 

</div>

----

Para remover o efeito do tamanho das coordenadas cartesianas,
podemos simplesmente dividir cada coordenada de cada *landmark*
de uma configuração pelo tamanho do centróide.

```{r}
### <b>
X.norm <- X / centroid.size(X)
### </b>
X.norm
centroid.size(X.norm)
```


<div class='columns-2'>

## Exemplo Mínimo {.smaller .build}

Vamos seguir os passos referentes à GPA no exemplo mínimo de dois
triângulos.

$$
X = \begin{bmatrix}
	-1 & -1 \\
	1 & -1 \\
	0 & 1 \\
	\end{bmatrix}
\qquad	
W = \begin {bmatrix}
	1.07 & -1.64 \\
	3.10 & -0.72 \\
	1.55 & 0.82 \\
	\end{bmatrix}
$$
	
<div class='centered'>
![](twotri.jpg)
</div>

## Translação {.smaller .build}

Esta operação lida com aquela variação proveniente do
posicionamento.

```{r}
X
W <- matrix (c(1.07, -1.64, 3.1, -0.72, 1.55, 0.82),  nrow = 3, byrow = TRUE)
W
```

---

<div class='centered'>

```{r, echo = FALSE, fig.width = 6, fig.height = 6}
plot (rbind (X, W), asp = 1, xlab = '', ylab = '', col = 'white', yaxp = c(-2, 1, 3))
points(rbind (X, X[1, ]), type = 'b', pch = 19)
points(rbind (W, W [1, ]), type = 'b', pch = 15)
text (0, -1/3, labels = 'X')
text (colMeans (W), labels = 'W')
```

</div>

---

A operação é relativamente simples: nós apenas subtraímos a posição do
centróide de cada configuração de suas coordenadas, efetivamente
deslocando o centróide de todas as configurações para o par $(0, 0)$.

<div class='centered'>
```{r, fig.width = 4, fig.height = 4, echo = FALSE}
par(mar = c(0, 0, 0, 0))
W.center <- scale(W, center = TRUE, scale = FALSE)
plot (rbind (W, W.center), asp = 1, xlab = '', ylab = '', col = 'white',
      yaxt = 'n', xaxt = 'n', bty = 'n')
points(rbind (W, W[1, ]), type = 'b', pch = 19, col = 'black')
points(rbind (W.center, W.center[1, ]), type = 'b', pch = 19, col = 'lightgrey')
arrows(W [, 1], W [, 2], W.center [, 1], W.center [, 2], lwd = 3, length = 0.15)
text (1.7, -.71, labels = 'W')
text (0, 0, labels = expression(W[c]))
```
</div>

## {.smaller}

A função *scale* dá conta de fazer isso:

```{r}
X.center <- scale(X, center = TRUE, scale = FALSE)
X.center
W.center <- scale(W, center = TRUE, scale = FALSE)
W.center
```

<div class='notes'>

Algumas funções produzem objetos que possuem atributos. Neste caso, a
função *scale* subtrai a posição do centróide original e retorna o
objeto *centralizado*. No entanto, ela retorna também um atributo
deste objeto, que se refere à posição original do centróide.

</div>

---

<div class='centered'>

```{r, echo = FALSE, fig.width = 6, fig.height = 6}
plot (rbind (X.center, W.center),
	  asp = 1, xlab = '', ylab = '', col = 'white', yaxp = c(-2, 1, 3), xaxp = c(-1, 1, 2))
points(rbind (X.center, X.center[1, ]), type = 'b', pch = 19)
points(rbind (W.center, W.center [1, ]), type = 'b', pch = 15)
text (0, 0.1, labels = expression(X[c]))
text (0, -0.1, labels = expression(W[c]))
```

</div>

## Escalonamento {.smaller .build}

Vamos escalonar ambos $X$ e $W$, desta vez guardando o $CS$ de cada configuração.

<div class='columns-2'>

```{r}
cs.X <- centroid.size(X)
cs.X
X.centerscale <- X.center / cs.X
X.centerscale
```

```{r}
cs.W <- centroid.size(W)
cs.W
W.centerscale <- W.center / cs.W
W.centerscale
```

</div>

---

<div class='centered'>

```{r, echo = FALSE, fig.width = 6, fig.height = 6}
plot (rbind (X.centerscale, W.centerscale),
	asp = 1, xlab = '', ylab = '', col = 'white', yaxp = c(-0.5, 0.5, 2),
	xaxp = c(-0.5, 0.5, 2))
points(rbind (X.centerscale, X.centerscale[1, ]), type = 'b', pch = 19)
points(rbind (W.centerscale, W.centerscale [1, ]), type = 'b', pch = 15)
text (0, 0.05, labels = expression(X[cs]))
text (0, -0.05, labels = expression(W[cs]))
```

</div>

## Rotação

<div class='columns-2'>

<div class='centered'>
![Rotação](rotation.jpg)
</div>

O que nós queremos é encontrar o ângulo $\theta$ que, ao rotacionar o
triângulo W, minimiza a soma dos quadrados das distâncias $d_1$, $d_2$
e $d_3$.

</div>

## Bibliografia {.smaller}

