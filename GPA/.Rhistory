aggregate (x = iris[, 1:4], by = list(Especies= iris$Species), FUN = mean)
mean.iris2 <- apply(iris[,1:4],c(3,4), mean )
mean.iris2 <- apply(iris, c(3,4), mean )
head(iris)
str(iris)
mean.iris2 <- apply(iris$Petal.Width, 1, mean )
mean.iris2 <- apply(iris$Petal.Width, c(1:4), mean )
dim(iris)
mean.iris2 <- apply(iris, c(1,5), mean )
mean.iris2 <- apply(iris[,1:4], c(1,5), mean )
aggregate (x = iris[, 1:4], by = list(iris$Species), FUN = mean)
by(warpbreaks[, 1:2], warpbreaks[,"tension"], mean)
by(warpbreaks[, 1],   warpbreaks[, -1],       summary)
by(warpbreaks[, 1:2], warpbreaks[,"tension"], function(x) mean(x))
by(warpbreaks[, 1:2], warpbreaks[,"tension"], mean)
by(warpbreaks[, 1:2], warpbreaks[,"tension"], colMean)
aggregate (x = iris[, 1:4], by = list(iris$Species), FUN = mean)
by(iris[, 1:4], Species, colMeans)
str(warpbreaks)
by(iris[, 1:4], iris[,"Species"], colMeans)
aggregate (x = iris[, 1:4], by = list(iris$Species), FUN = mean)
mean.iris <- aggregate (x = iris[, 1:4], by = list(Especies = iris$Species), FUN = mean)
(mean.iris <- aggregate (x = iris[, 1:4], by = list(Especies = iris$Species), FUN = mean) )
(meand.iris <- by(iris[, 1:4], iris[,"Species"], colMeans))
by(iris[, 1:4], iris[,5], colMeans)
class(meand.iris)
meand.iris
mean.iris
by(iris[, 1:4], iris[,"Species"], colMeans)
class(mean.iris)
mean.iris <- by(iris[, 1:4], iris[,"Species"], colMeans)
rm(X)
View(x)
mean.iris <- by(iris[, 1:4], iris[,"Species"], colMeans)
class(mean.iris)
aggregate (x = iris[, 1:4], by = list(Especies = iris$Species), FUN = mean) )
class(mean.iris)
aggregate (x = iris[, 1:4], by = list(Especies = iris$Species), FUN = mean)
class(mean.iris)
meand.iris <- aggregate (x = iris[, 1:4], by = list(Especies = iris$Species), FUN = mean)
class(mean.iris)
mean.iris <- aggregate (x = iris[, 1:4], by = list(Especies = iris$Species), FUN = mean)
class(mean.iris)
rm(X)
rm(meand.iris)
rm(x)
mean.iris <- by(iris[, 1:4], iris[,"Species"], colMeans) # em by deve ser usado ColMeans e nao mean.
aggregate (x = iris[, 1:4], by = list(iris$Species), FUN = mean)
apply(X = iris, MARGIN = c(3,2), FUN=mean)
mean.iris3
iris3
mean.iris
by(warpbreaks[, 1:2], warpbreaks[,"tension"], colMean)
str(warpbreaks)
by(warpbreaks[, 1:2], warpbreaks[,"tension"], colMean)
by(warpbreaks[, 1:2], warpbreaks[,"tension"], colMeans)
by(warpbreaks[, 1:2], warpbreaks[,"tension"], summary)
mean.iris3 <- apply(X = iris, MARGIN = c(3,2), FUN=mean)
mean.iris3 <- apply(X = iris3, MARGIN = c(3,2), FUN=mean)
mean.iris3
aggregate(. ~ Species, iris, mean)
mean.iris
dimnames(iris3)
iris[[3]]
head(iris3)
str(iris3)
length(iris3)
dim(iris)
dim(iris3)
dimnames(iris3)
dimnames(iris)
array(1:3, c(2,4))
x <- array(1:24, dim = c(2,3,4))
x
dim(iris3)
mean.iris3
mean.iris
str(iris3)
(ma <- matrix(c(1:4, 1, 6:8), nrow = 2))
(ma <- matrix(c(1:4, 1, 6:8), nrow = 2))
dim(ma)
dim(iris)
dim(iris3)
dimnames(iris3)
mean.iris3 <- apply(X = iris3, MARGIN = c(2,3), FUN=mean)
mean.iris3.2 <- apply(X = iris3, MARGIN = c(2,3), FUN=mean)
mean.iris3.2
mean.iris3
(ma <- matrix(c(1:4, 1, 6:8), nrow = 2))
dim(ma)
str(iris)
head(iris)
tail(iris)
dim(iris)
str(iris3)
class(iris3)
class(iris)
dim(iris)
dim(iris3)
head(iris3)
dim(iris3)
dimnames(iris3)
ma
dim(ma)
dimnames(ma)
head(iris3)
mean.iris4=by(iris[, 1:4], iris$Species, colMeans)
mean.iris4
class(warpbreaks)
attributes(mean.iris3)
dimnames(iris3)
names(iris3)
str(iris3)
?"["
mean.iris3
rownames(iris3)
rownames(mean.iris3) <- c("Sepala C.", "Sepala L.", "Petala C.", "Petala L.")
mean.iris3
mean.iris3 <- apply(X = iris3, MARGIN = c(2,3), FUN=mean)
mean.iris3
mean.iris3 <- apply(X = iris3, MARGIN = c(3,2), FUN=mean)
mean.iris3
dim(iris3)
dimnames(iris3)
mean.iris3 <- apply(X = iris3, MARGIN = c(2,3), FUN=mean)
mean.iris3
rownames(mean.iris3) <- c("Comprimento.Sepala", "Largura.Sepala", "Comprimento.Petala", "Largura.Petala")
mean.iris3
mean.iris <- by(iris[, 1:4], iris[,"Species"], colMeans) # em by deve ser usado ColMeans e nao mean.
mean.iris
dev.list()
library("ape", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
library("geiger", lib.loc="/Users/tafinha/Library/R/3.0/library")
library("ggplot2", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
library("phytools", lib.loc="/Users/tafinha/Library/R/3.0/library")
library("plyr", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
tree <- read.tree(text="
((((C.leiolepis:0.0168, C.nicterus:0.0099):0.0242
,C.sinebrachiatus:0.024):0.0724
,(S.catimbau:0.0652,N.ablephara:0.0309):0.0648):0.0659
,((((P.erythrocercus:0.0235,P.tetradactylus:0.0259):0.0462
,V.rubricauda:0.072):0.142
,M.maximiliani:0.1463):0.0225
,P.paeminosus:0.1093):0.0131);")
plot.phylo(tree, use.edge.length=FALSE)
require(ape)
require(plyr)
require(phytools)
require(geiger)
require(ggplot2)
tree <- read.tree(text="
((((C.leiolepis:0.0168, C.nicterus:0.0099):0.0242
,C.sinebrachiatus:0.024):0.0724
,(S.catimbau:0.0652,N.ablephara:0.0309):0.0648):0.0659
,((((P.erythrocercus:0.0235,P.tetradactylus:0.0259):0.0462
,V.rubricauda:0.072):0.142
,M.maximiliani:0.1463):0.0225
,P.paeminosus:0.1093):0.0131);")
plot.phylo(tree, use.edge.length=FALSE)
tree2 <- read.tree(text="
(((N.ablephara:38, S.catimbau:34):100
,((C.leiolepis:38, C.nicterus:33):43,
C.sinebrachiatus:65):72):188,
((V.rubricauda:107, M.maximiliani:94):46,
P.paeminosus:120):188);")
plot.phylo(tree2, use.edge.length=FALSE)
plot(tree)
plot(tree2)
plot.phylo(tree2, use.edge.length=FALSE)
tree2 <- read.tree(text="(((N.ablephara:38, S.catimbau:34):100, ((C.leiolepis:38, C.nicterus:33):43, C.sinebrachiatus:65):72):188, (P.paeminosus:120, ((V.rubricauda:65, (P.tetradactylus:34, P.erythrocercus:37):43):44, M.maximiliani:94):46):188);")
x11()
par(mfrow=c(1,2))
plot.phylo(tree, use.edge.length=FALSE)
plot.phylo(tree2, use.edge.length=FALSE)
par(mfrow=c(1,2))
plot.phylo(tree, use.edge.length=FALSE)
plot.phylo(tree2, use.edge.length=FALSE)
hist((tree$edge.length)*1000, breaks=c(50,10,150))
hist(tree2$edge.length)
hist(tree2$edge.length)
hist((tree$edge.length)*1000, breaks=c(50,10,150))
hist((tree$edge.length)*1000, breaks=c(50,10,150,200,250))
x11()
hist((tree$edge.length)*1000, breaks=c(50,10,150,200,250))
hist(tree2$edge.length)
tree <- read.tree(text="
((((C.leiolepis:0.0168, C.nicterus:0.0099):0.0242
,C.sinebrachiatus:0.024):0.0724
,(S.catimbau:0.0652,N.ablephara:0.0309):0.0648):0.0659
,((((P.erythrocercus:0.0235,P.tetradactylus:0.0259):0.0462
,V.rubricauda:0.072):0.142
,M.maximiliani:0.1463):0.0225
,P.paeminosus:0.1093):0.0131);")
hist((tree$edge.length)*1000, breaks=c(50,10,150,200,250))
plot.phylo(tree, use.edge.length=FALSE)
hist((tree$edge.length)*1000, breaks=c(50,10,150,200,250))
hist((tree$edge.length)*1000, breaks=c(50,100,150,200,250))
hist((tree$edge.length)*1000, breaks=c(50,100,150,200))
hist((tree$edge.length)*1000, breaks=c(0,50,100,150,200,250))
x11()
x11()
par(mfrow=c(1,2))
hist((tree$edge.length)*1000, breaks=c(0,50,100,150,200,250))
x11()
par(mfrow=c(1,2))
hist((tree$edge.length)*1000, breaks=c(0,50,100,150,200,250))
hist(tree2$edge.length)
require(bayou)
tree <- sim.bdtree(1, 0, n = 100)
x11()
tree$edge.length <- tree$edge.length/max(branching.times(tree))
plot(tree)
true.pars <- identifyBranches(tree, 3)
true.pars$alpha <- 2
true.pars$sig2 <- 1
true.pars$k <- 3
true.pars$ntheta <- 4
true.pars$theta <- c(0, -2, 2, 5)
true.pars$t2 <- 2:4
dat <- dataSim(true.pars, model="OU", tree)$dat
prior <- make.prior(tree, dists=list(dalpha="dhalfcauchy", dsig2="dhalfcauchy",dsb="dsb", dk="cdpois", dtheta="dnorm"), param=list(dalpha=list(scale=1), dsig2=list(scale=1), dk=list(lambda=10, kmax=200), dsb=list(bmax=1,prob=1), dtheta=list(mean=0, sd=2)))
ngen <- 20000
par(mfrow=c(2,3))
fit1 <- bayou.mcmc(tree, dat, SE=SE, model="OU", prior, ngen=ngen, new.dir=TRUE, plot.freq=2000, ticker.freq=1000)
SE=0
fit1 <- bayou.mcmc(tree, dat, SE=SE, model="OU", prior, ngen=ngen, new.dir=TRUE, plot.freq=2000, ticker.freq=1000)
fit1
chain <- load.bayou(fit1, save.Rdata=FALSE, cleanup=TRUE)
y
chain <- load.bayou(fit1, save.Rdata=FALSE, cleanup=TRUE)
chain <- set.burnin(chain, 0.3)
chain <- set.burnin(chain, 0.3)
chain <- load.bayou(fit1, save.Rdata=FALSE, cleanup=TRUE)
chain <- set.burnin(chain, 0.3)
out <- summary(chain)
prior <- make.prior(tree, dists=list(dalpha="dhalfcauchy", dsig2="dhalfcauchy",dsb="dsb", dk="cdpois", dtheta="dnorm"), param=list(dalpha=list(scale=1), dsig2=list(scale=1), dk=list(lambda=10, kmax=200), dsb=list(bmax=1,prob=1), dtheta=list(mean=0, sd=2)))
ngen <- 20000
par(mfrow=c(2,3))
fit1 <- bayou.mcmc(tree, dat, SE=SE, model="OU", prior, ngen=ngen, new.dir=TRUE, plot.freq=2000, ticker.freq=1000)
fit1
## We can load the actual chains by running the following code:
fit1
## We can load the actual chains by running the following code:
chain <- load.bayou(fit1, save.Rdata=FALSE, cleanup=TRUE)
chain <- set.burnin(chain, 0.3)
out <- summary(chain)
plot(chain)
par(mfrow=c(1,1))
plotSimmap.mcmc(pars2simmap(true.pars, tree)$tree, chain, burnin=0.3, circle=TRUE,fsize=0.4)
phenogram.density(tree, dat, chain=chain, burnin=0.3, pp.cutoff=0.3)
startpar <- list(alpha=1, sig2=1, k=3, ntheta=4, theta=rep(0,4), sb=true.pars$sb, loc=rep(0, 3), t2=true.pars$t2)
fixed.hypothesis <- list(k=startpar$k, sb=startpar$sb)
fixed.hypothesis
prior.fixed <- make.prior(tree, dists=list(dalpha="dhalfcauchy", dsig2="dhalfcauchy",dsb="fixed", dk="fixed", dtheta="dnorm", dloc="dloc"),
param=list(dalpha=list(scale=1), dsig2=list(scale=1), dtheta=list(mean=0, sd=2)),
fixed=fixed.hypothesis)
fit.fixed <- bayou.mcmc(tree, dat, SE=SE, model="OU", prior=prior.fixed, startpar=startpar, ngen=ngen, new.dir=TRUE)
chain.fixed <- load.bayou(fit.fixed, save.Rdata=FALSE, cleanup=FALSE)
chain.fixed <- set.burnin(chain.fixed, 0.3)
plot(chain.fixed)
phenogram.density(tree, dat, chain=chain.fixed, burnin=0.3, pp.cutoff=0.5)
plotSimmap.mcmc(tree, chain.fixed, burnin=0.3, circle=TRUE, fsize=0.5)
library("ggplot2", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
require(devtools)
install_github("bayou", username="uyedaj")
require(bayou)
tree <- sim.bdtree(1, 0, n = 100)
tree$edge.length <- tree$edge.length/max(branching.times(tree))
plot(tree)
x11()
tree$edge.length <- tree$edge.length/max(branching.times(tree))
plot(tree)
true.pars <- identifyBranches(tree, 3)
true.pars$alpha <- 2
true.pars$sig2 <- 1
true.pars$k <- 3
true.pars$ntheta <- 4
true.pars$theta <- c(0, -2, 2, 5)
true.pars$t2 <- 2:4
dat <- dataSim(true.pars, model="OU", tree)$dat
prior <- make.prior(tree, dists=list(dalpha="dhalfcauchy", dsig2="dhalfcauchy",dsb="dsb", dk="cdpois", dtheta="dnorm"), param=list(dalpha=list(scale=1), dsig2=list(scale=1), dk=list(lambda=10, kmax=200), dsb=list(bmax=1,prob=1), dtheta=list(mean=0, sd=2)))
ngen <- 20000
par(mfrow=c(2,3))
SE=0
fit1 <- bayou.mcmc(tree, dat, SE=SE, model="OU", prior, ngen=ngen, new.dir=TRUE, plot.freq=2000, ticker.freq=1000)
rm(SE)
fit1 <- bayou.mcmc(tree, dat, SE=SE, model="OU", prior, ngen=ngen, new.dir=TRUE, plot.freq=2000, ticker.freq=1000)
install.packages("phytools")
install.packages("phytools")
install.packages("phytools")
install.packages("phytools")
library("ggplot2", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
install.packages("phytools")
require(phytools)
install.packages("phytools", "coda")
set.seed(10)
set.seed(10) ## for repeatability
## load phytools
library(phytools)
library(mnormt)
require(mnormt)
library(mnormt)
tree<-pbtree(n=26,scale=1)
x11()
tree<-pbtree(n=26,scale=1)
tree$tip.label<-LETTERS[26:1]
x<-fastBM(tree,internal=TRUE)
C<-vcvPhylo(tree)
pp<-rep(1,tree$Nnode+1)
lik<-function(pp,C,x) -sum(dmnorm(c(x,pp[3:length(pp)]),
rep(pp[2],nrow(C)),pp[1]*C,log=TRUE))
tt<-setNames(c(1,rep(mean(x),tree$Nnode)),c("sig2",
1:tree$Nnode+length(tree$tip)))
fit<-optim(tt,lik,C=C,x=x[1:26],method="L-BFGS-B",lower=
c(1e-6,rep(-Inf,tree$Nnode)))
print(fit)
C
dim(C)
lik<-function(pp,C,x) -sum(dmnorm(c(x,pp[3:length(pp)]),
rep(pp[2],nrow(C)),pp[1]*C,log=TRUE))
head(tt)
tail(tt)
str(tt)
fit<-optim(tt,lik,C=C,x=x[1:26],method="L-BFGS-B",lower=
c(1e-6,rep(-Inf,tree$Nnode)))
fit
plot(x[1:tree$Nnode+length(tree$tip.label)],fit$par[1:tree$Nnode+1],
xlab="true states",ylab="estimated states")
lines(range(x),range(x),lty="dashed") ## 1:1 line
aa<-fastAnc(tree,x[tree$tip.label])
plot(aa,fit$par[2:length(fit$par)],xlab="fastAnc",ylab="custom")
lines(range(x), range(x), lty = "dashed")  ## 1:1 line
fit<-fastAnc(tree,x[tree$tip.label],CI=TRUE)
print(fit)
## this is the fraction of time that the true value is within our 95% CI
mean(((x[1:tree$Nnode+length(tree$tip.label)]>=fit$CI95[,1]) +
(x[1:tree$Nnode+length(tree$tip.label)]<=fit$CI95[,2]))==2)
## custom function that conducts a simulation, estimates ancestral
## states, & returns the fraction on 95% CI
foo<-function(){
tree<-pbtree(n=100)
x<-fastBM(tree,internal=TRUE)
fit<-fastAnc(tree,x[tree$tip.label],CI=TRUE)
mean(((x[1:tree$Nnode+length(tree$tip.label)]>=fit$CI95[,1]) +
(x[1:tree$Nnode+length(tree$tip.label)]<=fit$CI95[,2]))==2)
}
## conduct 100 simulations
pp<-replicate(100,foo())
mean(pp)
alpha<-2
tree<-pbtree(n=100,scale=1)
x<-fastBM(tree,internal=TRUE,model="OU",alpha=alpha,sig2=0.2)
phenogram(tree,x,ftype="off")
title("Evolution under OU")
plot of chunk unnamed-chunk-6
aa<-anc.ML(tree,x[tree$tip.label],model="OU")
plot(x[1:tree$Nnode+length(tree$tip.label)],aa$ace,
xlab="true values",ylab="estimated under OU")
lines(range(x),range(x),lty="dashed")
title("ancestral states estimated under OU")
tree<-pbtree(n=100,scale=1)
## simulate data with a trend
x<-fastBM(tree,internal=TRUE,mu=3)
phenogram(tree,x,ftype="off")
## let's see how bad we do if we ignore the trend
plot(x[1:tree$Nnode+length(tree$tip.label)],
fastAnc(tree,x[tree$tip.label]),
xlab="true values",ylab="estimated states under BM")
lines(range(x),range(x),lty="dashed")
title("estimated without prior information")
## incorporate prior knowledge
pm<-setNames(c(1000,rep(0,tree$Nnode)),
c("sig2",1:tree$Nnode+length(tree$tip.label)))
## the root & two randomly chosen nodes
nn<-as.character(c(length(tree$tip.label)+1,
sample(2:tree$Nnode+length(tree$tip.label),2)))
pm[nn]<-x[nn]
## prior variance
pv<-setNames(c(1000^2,rep(1000,length(pm)-1)),names(pm))
pv[as.character(nn)]<-1e-100
## run MCMC
mcmc<-anc.Bayes(tree,x[tree$tip.label],ngen=100000,
control=list(pr.mean=pm,pr.var=pv,
a=pm[as.character(length(tree$tip.label)+1)],
y=pm[as.character(2:tree$Nnode+length(tree$tip.label))]))
## let's see how bad we do if we ignore the trend
plot(x[1:tree$Nnode+length(tree$tip.label)],
fastAnc(tree,x[tree$tip.label]),
xlab="true values",ylab="estimated states under BM")
lines(range(x),range(x),lty="dashed")
title("estimated without prior information")
aa<-colMeans(mcmc[201:1001,as.character(1:tree$Nnode+length(tree$tip.label))])
plot(x[names(aa)],aa,xlab="true values",
ylab="estimated states using informative prior")
lines(range(x),range(x),lty="dashed")
title("estimated using informative prior")
data(anoletree)
x<-getStates(anoletree,"tips")
tree<-anoletree
rm(anoletree)
tree
x
plotTree(tree,type="fan",fsize=0.9,ftype="i")
cols<-setNames(palette()[1:length(unique(x))],sort(unique(x)))
tiplabels(pie=to.matrix(x,sort(unique(x))),piecol=cols,cex=0.2)
add.simmap.legend(colors=cols,prompt=FALSE,x=0.9*par()$usr[1],
y=-max(nodeHeights(tree)))
fitER<-rerootingMethod(tree,x,model="ER")
print(lapply(fitER,round,digits=3))
plotTree(tree,type="fan",fsize=0.9,ftype="i")
nodelabels(node=as.numeric(rownames(fitER$marginal.anc)),
pie=fitER$marginal.anc,piecol=cols,cex=0.5)
tiplabels(pie=to.matrix(x,sort(unique(x))),piecol=cols,cex=0.2)
add.simmap.legend(colors=cols,prompt=FALSE,x=0.9*par()$usr[1],
y=-max(nodeHeights(tree)))
mtree<-make.simmap(tree,x,model="ER")
plotSimmap(mtree,cols,type="fan",fsize=0.9,ftype="i")
add.simmap.legend(colors=cols,prompt=FALSE,x=0.9*par()$usr[1],
y=-max(nodeHeights(tree)))
mtrees<-make.simmap(tree,x,model="ER",nsim=100)
par(mfrow=c(10,10))
plotSimmap(mtrees,cols,lwd=1,ftype="off")
pd<-describe.simmap(mtrees,plot=FALSE)
pd
plotSimmap(mtree,cols,type="fan",fsize=0.9,ftype="i")
x11()
plotSimmap(mtree,cols,type="fan",fsize=0.9,ftype="i")
nodelabels(pie=pd$ace,piecol=cols,cex=0.5)
add.simmap.legend(colors=cols,prompt=FALSE,x=0.9*par()$usr[1],
y=-max(nodeHeights(tree)))
plot(fitER$marginal.anc,pd$ace,xlab="marginal ancestral states",
ylab="posterior probabilities from stochastic mapping")
library("rgl", lib.loc="~/Library/R/3.0/library")
plot3d(1:10, 1:10, 1:10)
require(geomorph)
hummingbirds
hummingbird
data(hummingbirds)
hummingbirds
plot(hummingbirds[,,1])
plot(hummingbirds[[1]] [,,1])
digitize2d("/users/tafinha/Desktop/procavia.jpg")
digitize2d(filelist="/users/tafinha/Desktop/procavia.jpg",nlandmarks = 12,tpsfile = 'test.tps' )
digitize2d(filelist=list("/users/tafinha/Desktop/procavia.jpg"),nlandmarks = 12,tpsfile = 'test.tps' )
digitize2d(filelist=list("/users/tafinha/Desktop/procavia.jpg"),nlandmarks = 12,tpsfile = 'test.tps' )
digitize2d(filelist="/users/tafinha/Desktop/procavia.jpg",nlandmarks = 12,tpsfile = 'test.tps' )
plot(hummingbirds[[1]] [,,1])
require(geomorph)
install.packages('geomorph', dependencies = TRUE)
install.packages('shapes', dependencies = TRUE)
require(geomorph)
require(shapes)
install.packages('rgl', dependencies = TRUE)
require(geomorph)
library("rgl", lib.loc="~/Library/R/3.0/library")
detach("package:rgl", unload=TRUE)
require(geomorph)
system("locate libXft.2.dylib")
install.packages('geomorph', dependencies = TRUE)
install.packages('shapes', dependencies = TRUE)
install.packages('rgl', dependencies = TRUE)
require(geomorph)
require(shapes)
install.packages('rmarkdown')
---
---
title: "Generalized Procrustes Analysis"
title: "Generalized Procrustes Analysis"
require(shapes)
require(geomorph)
exercicio <- readland.tps(file = 'exercicio.tps') ### atribuição
require (geomorph) ### carregar o pacote.
?readland
?readland.tps
exercicio <- readland.tps(file = 'exercicio.tps') ### criando um objeto.
exercicio
data(hummingbirds)
define.sliders.2d(hummingbirds$land[,,1], nsliders=10)
x11()
define.sliders.2d(hummingbirds$land[,,1], nsliders=10)
GPA <- gpagen(exercicio.semi, ShowPlot = TRUE, curves = slm)
x11()
define.sliders.2d(hummingbirds$land[,,1], nsliders=10)
slm <- define.sliders.2d (exercicio [, , 1], 31)
require("geomorph")
require("shapes")
require(shapes)
require(mvnorm)
require(geomorph)
require(ggplot2)
require(shapes)
require(mvnorm)
require(geomorph)
require(ggplot2)
install.packages("mvnorm")
require(shapes)
require(mvtnorm)
require(geomorph)
require(ggplot2)
install.packages(c("animation", "bayou", "car", "caTools", "corHMM", "corpcor", "dendextend", "deSolve", "expands", "FD", "flexmix", "formatR", "geometry", "gsubfn", "highr", "htmltools", "httpuv", "jaatha", "knitr", "magrittr", "maps", "markdown", "mclust", "mime", "mnormt", "msm", "nlme", "OutbreakTools", "paleotree", "pegas", "phyloland", "phylolm", "phytools", "plotrix", "R.utils", "raster", "RcppArmadillo", "seqinr", "sp", "spam", "splancs", "strap", "subplex", "taxize", "Taxonstand", "TreePar", "TreeSim", "vegan", "VGAM", "xtable"))
install.packages(c("ape", "boot", "class", "cluster", "codetools", "devtools", "ggplot2", "httr", "KernSmooth", "labeling", "MASS", "Matrix", "mgcv", "mvtnorm", "nlme", "Rcpp", "RCurl", "vegan"), lib="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
setwd("~/Copy/MGeo/GPA")
---
title: "Generalized Procrustes Analysis"
setwd("~/Copy/MGeo/GPA")
Sys.setlocale
Sys.setlocale
Sys.setlocale()
sessionInfo()
as.list(Sys.getenv())
version()
sessionInfo()
