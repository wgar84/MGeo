require(geomorph)
require(rgl)
require(geomorph)
library("rgl", lib.loc="~/Library/R/3.0/library")
require(geomorph)
data (hummingbirds)
require(geomorph)
data (plethodon)
data (plethodon)
plethodon
names(plethodon)
class(plethodon)
dim(plethodon)
dimnames(plethodon)
class(plethodon$land)
class(plethodon$links)
class(plethodon$species)
class(plethodon$site)
plethodon$land
plethodon$links
plethodon$species
plethodon$site
class(plethodon)
attributes(plethodon)
dim(plethodon)
nrow(plethodon)
ncol(plethodon)
dimnames(plethodon)
names(plethodon)
rownames(plethodon)
is.numeric()
is.numeric(plethodon)
class(plethodon)
attributes(plethodon)
dim(plethodon)
dimnames(plethodon)
names(plethodon)
rownames(plethodon)
is.numeric(plethodon)
is.numeric(plethodon)
data (scallops)
scallops
scallops
class(scallops)
attributes(scallops)
dim(scallops) #nao se aplica
nrow(scallops) #nao se aplica
ncol(scallops) #nao se aplica
dimnames(scallops) #nao se aplica
names(scallops)
rownames(scallops)#nao se aplica
is.numeric(scallops)
class(scallops$coorddata)
class(scallops$curvslide)
class(scallops$surfslide)
class(scallops$ind)
class(scallops$land.pairs)
data (ratland)
ratland
class(ratland)
attributes(ratland)
dim(ratland) #nao se aplica
nrow(ratland) #nao se aplica
ncol(ratland) #nao se aplica
dimnames(ratland) #nao se aplica
names(ratland)
rownames(ratland)#nao se aplica
is.numeric(ratland)
names(ratland)
dim(ratland) #nao se aplica
dim(ratland)
attributes(ratland)
dim(ratland)
nrow(ratland)
ncol(ratland)
dimnames(ratland) #nao se aplica
names(ratland)
rownames(ratland)#nao se aplica
is.numeric(ratland)
class(ratland)
ratland.tps
mydata <- readland.tps("ratland.tps", specID="ID")
ratland.tps()
ratland.tps
mydata <- readland.tps("ratland.tps", specID="ID")
rats.nts
data (ratland)
mydata <- readland.tps("ratland.tps", specID="ID")
data (plethodon)
Y <- gpagen(plethodon$land)
Y
head(Y)
class(Y)
names(Y)
gpagen
gpagen ()
function(gpagen)
gpagen
gpagen()
args(gpagen)
args(gpagen)
plethodon$land
Y
class(Y)
names(Y)
names(Y)
args(gpagen)
class(plethodon)
data (hummingbirds) #carrega os dados
data (hummingbirds)
hummingbirds
class(hummingbirds)
class(plethodon)
attributes(hummingbirds)
attributes(hummingbirds)
dim(hummingbirds) #nao se aplica
nrow(hummingbirds) #nao se aplica
ncol(hummingbirds) #nao se aplica
dimnames(hummingbirds) #nao se aplica
names(hummingbirds)
rownames(hummingbirds)#nao se aplica
is.numeric(hummingbirds)
class(hummingbirds$land)
class(hummingbirds$curvepts)
hummingbirds$land
hummingbirds$curvepts
class(hummingbirds$curvepts)
class(hummingbirds$land)
hummingbirds$curvept
hummingbirds$curvepts
class(hummingbirds)
names (hummingbirds)
hummingbirds$curvepts #matriz que mostra quais pontos sao semilandmarks (coluna do meio) e quais direções eles
args(gpagen)
Z <- gpagen(hummingbirds$land, curves=hummingbirds$curvepts)
Z
names(Z)
W <- gpagen(hummingbirds$land, curves=hummingbirds$curvepts, ProcD=FALSE)
Z <- gpagen(hummingbirds$land, curves=hummingbirds$curvepts) #aplica a funcao gpagen nas coordenadas dos dados
Z <- gpagen(hummingbirds$land, curves=hummingbirds$curvepts) #aplica a funcao gpagen nas coordenadas dos dados
W <- gpagen(hummingbirds$land, curves=hummingbirds$curvepts, ProcD=FALSE)
data (scallops)
scallops
class(scallops)
attributes(scallops)
dim(scallops) #nao se aplica
nrow(scallops) #nao se aplica
ncol(scallops) #nao se aplica
dimnames(scallops) #nao se aplica
names(scallops)
rownames(scallops)#nao se aplica
is.numeric(scallops)
class(scallops$coorddata)
class(scallops$curvslide)
class(scallops$surfslide)
class(scallops$ind)
class(scallops$land.pairs)
scallops$coorddata
scallops$curvslide
scallops$surfslide
scallops$ind
scallops$land.pairs
class(scallops) #scallops e uma lista
names (scallops) # uma lista que contem land e curvepts
scallops$curvslide
scallops$surfslide
args(gpagen) # já que estamos falando de semilandmarks temos que dar uma informacao para curves na funcao
S <- gpagen (A=scallops$coorddata, curves=scallops$curvslide, surfaces=scallops$surfslide)
S <- gpagen (A=scallops$coorddata, curves=scallops$curvslide, surfaces=scallops$surfslide)
Y$coords
Y #a funcao retorna uma lista contendo as corrdenadas de Procrustes ($coord), os tamanhos dos centroides
Y$coords
Z$coords
S$coords
dim(plethodon) #nao se aplica
args(plotTangentSpace)
require(geomorph)
args(plotTangentSpace)
data(plethodon)
Y.gpa<-gpagen(plethodon$land) #GPA-alignment
ref<-mshape(Y.gpa$coords)
ref
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site))
args(plotTangentSpace) #olhar os argumentos da funcao
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site), verbose = TRUE)
plotTangentSpace(Y.gpa$coords, verbose=T, groups = paste(plethodon$species,plethodon$site))
plotTangentSpace(Y.gpa$coords, verbose=T, groups = paste(plethodon$species,plethodon$site))
Y.gpa<-gpagen(plethodon$land) #GPA-alignment
ref<-mshape(Y.gpa$coords) #estima a media da forma para um conjunto de especimes alinhadas
ref
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site), verbose=T)
$pc.scores
Y.gpa$pc.scores
Y.gpa
data(plethodon)
Y.gpa<-gpagen(plethodon$land) #GPA-alignment
ref<-mshape(Y.gpa$coords) #estima a media da forma para um conjunto de especimes alinhadas
ref
alfa <- plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site), verbose=T)
alfa
alfa <- plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site), verbose=T)
data(plethodon)
Y.gpa<-gpagen(plethodon$land) #GPA-alignment
ref<-mshape(Y.gpa$coords) #estima a media da forma para um conjunto de especimes alinhadas
ref
x11()
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site), verbose=T)
plotRefToTarget().
plotRefToTarget()
args(plotRefToTarget)
$pc.scores
ref$pc.scores
class(ref)
class(Y.gpa)
Y.gps$pc.scores
Y.gpa$pc.scores
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site), verbose=T)
Y.gpa$pc.scores
names(Y.gpa)
mshape(Y.gpa$coords)
mshape(Y.gpa$pc.score)
mshape(Y.gpa$pc.scores)
data(plethodon)
Y.gpa<-gpagen(plethodon$land) #GPA-alignment
args(plotTangentSpace) #olhar os argumentos da funcao
ref<-mshape(Y.gpa$coords) #estima a media da forma para um conjunto de especimes alinhadas
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site), verbose=T)
library("car", lib.loc="~/Library/R/3.0/library")
library("ggplot2", lib.loc="~/Library/R/3.0/library")
library("MASS", lib.loc="~/Library/R/3.0/library")
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site), verbose=T)
$pc.scores
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site), verbose=T)
ref<-mshape(Y.gpa$coords) #estima a media da forma para um conjunto de especimes alinhadas
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site), verbose=T)
x11()
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site), verbose=T)
x11()
plotRefToTarget(ref,Y.gpa$coords[,,39])
plotRefToTarget(ref,Y.gpa$coords[,,39],mag=3)   #magnify difference by 3X
plotRefToTarget(ref,Y.gpa$coords[,,39],method="vector")
plotRefToTarget(ref,Y.gpa$coords[,,39],method="points")
ref,Y.gpa$pc.scores
Y.gpa$pc.scores
ref(Y.gpa$pc.scores)
ref$Y.gpa$pc.scores
class(ref)
names(ref)
dimnames(ref)
data(scallops)
Y.gpa<-gpagen(A=scallops$coorddata, curves=scallops$curvslide, surfaces=scallops$surfslide)
ref<-mshape(Y.gpa$coords)
plotRefToTarget(ref,Y.gpa$coords[,,1],method="points")
data(scallops)
X11()
Y.gpa<-gpagen(A=scallops$coorddata, curves=scallops$curvslide, surfaces=scallops$surfslide)
ref<-mshape(Y.gpa$coords)
plotRefToTarget(ref,Y.gpa$coords[,,1],method="points")
pc.summary
data(plethodon)
Y.gpa<-gpagen(plethodon$land)    #GPA-alignment
gp <- as.factor(paste(plethodon$species, plethodon$site)) # group must be a factor
plotTangentSpace(Y.gpa$coords, groups = gp, verbose=T)
col.gp<-c(rep("black",10),rep("red",10),rep("yellow",10),rep("orange",10)) # must not be a factor
plotTangentSpace(Y.gpa$coords, groups = col.gp)
col.gp<-c(rep("black",10),rep("red",10),rep("yellow",10),rep("orange",10)) # must not be a factor
plotTangentSpace(Y.gpa$coords, groups = col.gp)
plotTangentSpace(Y.gpa$coords, groups = col.gp, verbose=T)
data(plethodon)
Y.gpa<-gpagen(plethodon$land)    #GPA-alignment
gp <- as.factor(paste(plethodon$species, plethodon$site)) # group must be a factor
plotTangentSpace(Y.gpa$coords, groups = gp, verbose=T)
$pc.scores
gp$pc.scores
Y.gpa$pc.scores
names(Y.gpa)
names(gp)
args(plotTangentSpace) #olhar os argumentos da funcao
data(plethodon)
Y.gpa<-gpagen(plethodon$land)    #GPA-alignment
data(plethodon)
Y.gpa<-gpagen(plethodon$land)    #GPA-alignment
gp <- as.factor(paste(plethodon$species, plethodon$site)) # group must be a factor
plotTangentSpace(Y.gpa$coords, groups = gp, warpgrids=T, verbose=t)
data(plethodon)
Y.gpa<-gpagen(plethodon$land)    #GPA-alignment
x11()
gp <- as.factor(paste(plethodon$species, plethodon$site)) # group must be a factor
plotTangentSpace(Y.gpa$coords, groups = gp, warpgrids=T, verbose=t)
data(plethodon)
Y.gpa<-gpagen(plethodon$land)    #GPA-alignment
x11()
gp <- as.factor(paste(plethodon$species, plethodon$site)) # group must be a factor
plotTangentSpace(Y.gpa$coords, groups = gp, warpgrids=T, verbose=T)
$pc.summary
Y.gpa$pc.summary
Y.gpa$coords$pc.summary
args(plotRefToTarget)
Y.gpa$coords[,,39]
data(plethodon)
Y.gpa<-gpagen(plethodon$land) #GPA-alignment
ref<-mshape(Y.gpa$coords) #estima a media da forma para um conjunto de especimes alinhadas
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site))
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site), verbose=T)
data(plethodon)
Y.gpa<-gpagen(plethodon$land)    #GPA-alignment
ref<-mshape(Y.gpa$coords) #estima a media da forma para um conjunto de especimes alinhadas
x11()
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site))
gp <- as.factor(paste(plethodon$species, plethodon$site)) # group must be a factor
plotTangentSpace(Y.gpa$coords, groups = gp, warpgrids=T, verbose=T)
args(plotTangentSpace) #olhar os argumentos da funcao
data(plethodon)
Y.gpa<-gpagen(plethodon$land) #GPA-alignment
ref<-mshape(Y.gpa$coords) #estima a media da forma para um conjunto de especimes alinhadas
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site))
data(plethodon)
Y.gpa<-gpagen(plethodon$land)    #GPA-alinhamento
ref<-mshape(Y.gpa$coords) #estima a media da forma para um conjunto de especimes alinhadas
x11() #abra janela para visualizacao grafica no mac
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site))
gp <- as.factor(paste(plethodon$species, plethodon$site)) # o grupo devera ser um fator
plotTangentSpace(Y.gpa$coords, groups = gp, warpgrids=T, verbose=T)
col.gp<-c(rep("black",10),rep("red",10),rep("yellow",10),rep("orange",10)) # must not be a factor
plotTangentSpace(Y.gpa$coords, groups = col.gp, warpgrids=T, verbose=T)
x11() #abra janela para visualizacao grafica no mac
plotTangentSpace(Y.gpa$coords, groups = paste(plethodon$species,plethodon$site)) #visualizacao dos grupos no PC1  e PC2
gp <- as.factor(paste(plethodon$species, plethodon$site)) # o grupo devera ser um fator
plotTangentSpace(Y.gpa$coords, groups = gp, warpgrids=T, verbose=T)
col.gp<-c(rep("black",10),rep("red",10),rep("yellow",10),rep("orange",10)) # must not be a factor
plotTangentSpace(Y.gpa$coords, groups = col.gp, warpgrids=T, verbose=T)
x11()
plotRefToTarget(ref,Y.gpa$coords[,,39])
plotRefToTarget(ref,Y.gpa$coords[,,39],mag=3) #mag: magnifica a diferenca por 3x
plotRefToTarget(ref,Y.gpa$coords[,,39],method="vector")
plotRefToTarget(ref,Y.gpa$coords[,,39])
plotRefToTarget(ref,Y.gpa$coords[,,39],mag=3) #mag: magnifica a diferenca por 3x
plotRefToTarget(ref,Y.gpa$coords[,,39],method="vector")
plotRefToTarget(ref,Y.gpa$coords[,,39],method="points")
data(scallops)
Y.gpa<-gpagen(A=scallops$coorddata, curves=scallops$curvslide, surfaces=scallops$surfslide)
ref<-mshape(Y.gpa$coords)
plotRefToTarget(ref,Y.gpa$coords[,,1],method="points")
args(plotAllometry)
data(ratland)
Y.gpa<-gpagen(ratland)    #GPA-alignment
plotAllometry(Y.gpa$coords,Y.gpa$Csize,method="CAC", iter=5)
data(ratland)
Y.gpa<-gpagen(ratland)    #GPA-alignment
x11()
plotAllometry(Y.gpa$coords,Y.gpa$Csize,method="CAC", iter=5)
source("https://raw.github.com/lem-usp/lem-usp-R/master/matrix.func.r")
source("./functions.r")
require(car)
data.folder = ("./dados-limpos")
otu = dir(data.folder)
num.traits = 35
main.data = list()
cov.matrices = list()
cor.matrices = list()
source("https://raw.github.com/lem-usp/lem-usp-R/master/matrix.func.r")
source("./functions.r")
require(car)
data.folder = ("./dados-limpos")
otu = dir(data.folder)
num.traits = 35
main.data = list()
cov.matrices = list()
cor.matrices = list()
for (species in 1:length(otu)){
print (otu[[species]])
main.data[[species]] = ReadFolder(otu[[species]], num.traits)
cov.matrices[[species]] = main.data[[species]]$ext.cov.matrix
cor.matrices[[species]] = main.data[[species]]$cor.matrix
}
names(main.data) = names(cov.matrices) = names(cor.matrices) = otu
mat.reps = lapply(main.data, CalcRepGen)
pc.iso.compare = lapply(main.data, FindSize) # mostra as correl. do vetor isometrico com os PCs das matrizes
for (genero in 1:length(main.data)){
main.data[[genero]]$mat.reps = mat.reps[[genero]]
main.data[[genero]]$pc.iso.compare = pc.iso.compare[[genero]]
}
nomes.index = unlist(scan("ordem.de.taxons.txt", character()))
main.data = main.data[nomes.index]
cov.matrices = cov.matrices[nomes.index]
cor.matrices = cor.matrices[nomes.index]
save(main.data, cov.matrices, cor.matrices, file = "./output/main.data.Rdata")
write.csv(pc.iso.compare, "./output/pc.iso.compare.csv")
data.folder = ("./dados-limpos")
amostra = num.ind,
ReadFolder = function(especie, num.traits){
current.folder = paste(data.folder, especie, sep='/')
arquivos = dir(current.folder)
current.file = arquivos[grep('.*distancias.*txt', arquivos, perl = T)]
current.file = paste(current.folder, current.file , sep='/')
especie.distancias<- read.table(current.file,
as.is=TRUE, header=TRUE,sep="\t",
blank.lines.skip=FALSE)
num.ind = sum(!(is.na(especie.distancias[,9])))
especie.distancias = especie.distancias[1:num.ind,]
raw.distances = as.matrix(especie.distancias[,9:43])
options (constrasts=c("contr.sum", "contr.poly"))
current.file = paste(current.folder, "/", "modelo.txt", sep='')
modelo = paste("raw.distances", scan(current.file, character()), sep= '~')
modelo.manova = lm(as.formula(modelo), data= especie.distancias)
cov.matrix<- CalculateMatrix(modelo.manova)
cor.matrix<-cov2cor(cov.matrix)
r2<-(mean (cor.matrix[lower.tri (cor.matrix)]^2))
eigen.out = eigen(cov.matrix)
eVal = eigen.out$values
eVec = eigen.out$vectors
PCA.percent = eVal/sum(eVal)
media <- apply(especie.distancias[,9:43],2,FUN=summary)
require(Matrix)
if(num.ind < num.traits+1){
ext.cov.matrix = as.matrix(nearPD(cov.matrix)$mat)
}
else{
ext.cov.matrix = cov.matrix
}
ListHansen = function(mat) HansenHouleAverage(mat, 1000)$mean
hhstats = ListHansen (ext.cov.matrix)
residuals = modelo.manova$residuals
df.residual = modelo.manova$df.residual
output = list(distancias = raw.distances,
info = especie.distancias[,1:8],
amostra = num.ind,
modelo = modelo,
residuals = residuals,
cov.matrix = cov.matrix,
ext.cov.matrix = ext.cov.matrix,
cor.matrix = cor.matrix,
hhstats = hhstats,
means = media,
r2 = r2,
eVal = eVal,
eVec = eVec,
PCA.percent = 100*PCA.percent,
df.residual= df.residual)
return(output)
}
CalcRepGen = function(current.otu){
cov.matrix = current.otu$ext.cov.matrix
cor.matrix = cov2cor(cov.matrix)
sample = current.otu$amostra
cov.rep.rs = MonteCarloRep (cov.matrix, sample)
cor.rep.mantel = MonteCarloRep (cor.matrix, sample)
cov.rep.krz = MonteCarloRep (cov.matrix, sample, ComparisonFunc = KrzCor)
cor.rep.krz = MonteCarloRep (cor.matrix, sample, ComparisonFunc = KrzCor)
alpha.rep = AlphaRep(cor.matrix, sample)
output = list(cov.rep.rs = cov.rep.rs,
cor.rep.mantel = cor.rep.mantel,
cov.rep.krz = cov.rep.krz,
cor.rep.krz = cor.rep.krz,
alpha.rep = alpha.rep)
return(output)
}
CalcHHGen = function(current.otu){
output = c(current.otu$hhstats[c(2:4,7,8)], current.otu$r2)
names(output) = c(names(output[-length(output)]), 'r2')
return(output)
}
FindSize = function(otu){
iso.vector = rep(1/sqrt(num.traits), num.traits)
pc.iso.corr = apply(otu$eVec, 2, function(x) abs(x%*%iso.vector))
return(pc.iso.corr)
}
load("/Users/dani/Downloads/main.data-2.Rdata")
load("/Users/dani/Downloads/main.data-3.Rdata")
main.data ()
main.data$amostra
require (geomorph)
data(ratland)
Y.gpa<-gpagen(ratland)    #GPA-alignment
plotAllometry(Y.gpa$coords,Y.gpa$Csize,method="CAC")
plotAllometry(Y.gpa$coords,Y.gpa$Csize,method="RegScore")
plotAllometry(Y.gpa$coords,Y.gpa$Csize,method="PredLine")
data(rats)
rat.gpa<-gpagen(ratland)
plotAllometry(rat.gpa$coords,rat.gpa$Csize,
method=CAC)
plotAllometry(rat.gpa$coords,rat.gpa$Csize,
method="CAC")
procD.lm(two.d.array(rat.gpa$coords)~rat.gpa
$Csize,iter=999)
ratland
class(ratland)
attributes(ratland)
dim(ratland)
nrow(ratland)
ncol(ratland)
is.numeric(ratland)
plotAllometry(Y.gpa$coords,Y.gpa$Csize,method="CAC")
x11()
plotAllometry(Y.gpa$coords,Y.gpa$Csize,method="CAC")
plotAllometry(Y.gpa$coords,Y.gpa$Csize,method="RegScore")
x11()
plotAllometry(Y.gpa$coords,Y.gpa$Csize,method="RegScore")
plotAllometry(Y.gpa$coords,Y.gpa$Csize,method="PredLine")
setwd("~/Copy/MGeo/GPA")
